import express from 'express';
import { body, validationResult } from 'express-validator';
import { authenticateToken } from './auth.js';
import Leak from '../models/Leak.js';
import ServiceRequest from '../models/ServiceRequest.js';
import User from '../models/User.js';


const router = express.Router();

// @route   POST /api/leaks/report
// @desc    Report a new leak (manual or IoT sensor)
// @access  Private (Staff only)
router.post('/report', authenticateToken, [
  body('title').notEmpty().withMessage('Title is required'),
  body('description').notEmpty().withMessage('Description is required'),
  body('severity').isIn(['low', 'medium', 'high', 'critical']).withMessage('Valid severity level required'),
  body('location.coordinates').isArray({ min: 2, max: 2 }).withMessage('Valid coordinates required'),
  body('location.address').notEmpty().withMessage('Address is required'),
  body('reportMethod').isIn(['manual', 'iot_sensor', 'system_alert']).withMessage('Valid report method required')
], async (req, res) => {
  try {
    // Only staff can report leaks
    if (req.userType !== 'staff') {
      return res.status(403).json({ message: 'Only staff members can report leaks' });
    }

    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const {
      title,
      description,
      severity,
      location,
      reportMethod,
      sensorData,
      images,
      isEmergency,
      waterShutoff,
      tags
    } = req.body;

    // Create new leak report
    const leak = new Leak({
      title,
      description,
      severity,
      location,
      reportedBy: req.user._id,
      reportMethod,
      sensorData: sensorData || {},
      images: images || [],
      isEmergency: isEmergency || false,
      waterShutoff: waterShutoff || { required: false },
      tags: tags || []
    });

    // Calculate initial priority
    await leak.calculatePriority();
    await leak.save();

    // Emit real-time notification to connected staff
    const io = req.app.get('io');
    io.to('staff-room').emit('new-leak-report', {
      leak: leak,
      reportedBy: req.user.name,
      timestamp: new Date()
    });

    // Auto-create service request for high priority leaks
    if (leak.severity === 'critical' || leak.isEmergency) {
      const serviceRequest = new ServiceRequest({
        leak: leak._id,
        requestedBy: req.user._id,
        serviceType: 'emergency_service',
        priority: 'emergency',
        location: location,
        status: 'plumber_search'
      });
      
      // The requestId will be auto-generated by the pre-save middleware

      await serviceRequest.save();
      
      // Link service request to leak
      leak.assignedService = serviceRequest._id;
      leak.status = 'assigned';
      await leak.save();

      // Notify nearby plumbers for emergency
      io.to('plumber-room').emit('emergency-service-request', {
        serviceRequest: serviceRequest,
        leak: leak
      });
    }

    res.status(201).json({
      message: 'Leak reported successfully',
      leak: leak
    });

  } catch (error) {
    console.error('Leak report error:', error);
    res.status(500).json({ message: 'Server error while reporting leak' });
  }
});

// @route   GET /api/leaks
// @desc    Get all leaks with optional filters
// @access  Private
router.get('/', authenticateToken, async (req, res) => {
  try {
    const {
      status,
      severity,
      reportMethod,
      isEmergency,
      page = 1,
      limit = 10,
      sortBy = 'priority',
      sortOrder = 'desc'
    } = req.query;

    // Build query
    const query = {};
    if (status) query.status = status;
    if (severity) query.severity = severity;
    if (reportMethod) query.reportMethod = reportMethod;
    if (isEmergency !== undefined) query.isEmergency = isEmergency === 'true';

    // For staff, show all leaks
    // For plumbers, only show leaks they might be assigned to
    if (req.userType === 'plumber') {
      // Show leaks with assigned services or emergency leaks in their area
      const plumberLocation = req.user.location.coordinates;
      query.$or = [
        { assignedService: { $exists: true } },
        {
          isEmergency: true,
          location: {
            $near: {
              $geometry: {
                type: 'Point',
                coordinates: plumberLocation
              },
              $maxDistance: req.user.location.serviceRadius * 1000 // convert km to meters
            }
          }
        }
      ];
    }

    const sortOptions = {};
    sortOptions[sortBy] = sortOrder === 'desc' ? -1 : 1;

    const leaks = await Leak.find(query)
      .populate('reportedBy', 'name email department')
      .populate('assignedService')
      .sort(sortOptions)
      .limit(limit * 1)
      .skip((page - 1) * limit);

    const total = await Leak.countDocuments(query);

    res.json({
      leaks,
      totalPages: Math.ceil(total / limit),
      currentPage: page,
      total
    });

  } catch (error) {
    console.error('Get leaks error:', error);
    res.status(500).json({ message: 'Server error while fetching leaks' });
  }
});

// @route   GET /api/leaks/active
// @desc    Get all active leaks
// @access  Private
router.get('/active', authenticateToken, async (req, res) => {
  try {
    const activeLeaks = await Leak.getActiveLeaks()
      .populate('reportedBy', 'name email department')
      .populate('assignedService');

    res.json({ leaks: activeLeaks });

  } catch (error) {
    console.error('Get active leaks error:', error);
    res.status(500).json({ message: 'Server error while fetching active leaks' });
  }
});

// @route   GET /api/leaks/nearby
// @desc    Get nearby leaks based on location
// @access  Private
router.get('/nearby', authenticateToken, async (req, res) => {
  try {
    const { latitude, longitude, radius = 1000 } = req.query;

    if (!latitude || !longitude) {
      return res.status(400).json({ message: 'Latitude and longitude are required' });
    }

    const coordinates = [parseFloat(longitude), parseFloat(latitude)];
    const nearbyLeaks = await Leak.getNearbyLeaks(coordinates, radius)
      .populate('reportedBy', 'name email department')
      .populate('assignedService');

    res.json({ leaks: nearbyLeaks });

  } catch (error) {
    console.error('Get nearby leaks error:', error);
    res.status(500).json({ message: 'Server error while fetching nearby leaks' });
  }
});

// @route   GET /api/leaks/:id
// @desc    Get leak by ID
// @access  Private
router.get('/:id', authenticateToken, async (req, res) => {
  try {
    const leak = await Leak.findById(req.params.id)
      .populate('reportedBy', 'name email department phone')
      .populate('assignedService')
      .populate('timeline.updatedBy', 'name email');

    if (!leak) {
      return res.status(404).json({ message: 'Leak not found' });
    }

    res.json({ leak });

  } catch (error) {
    console.error('Get leak error:', error);
    res.status(500).json({ message: 'Server error while fetching leak' });
  }
});

// @route   PUT /api/leaks/:id/status
// @desc    Update leak status
// @access  Private
router.put('/:id/status', authenticateToken, [
  body('status').isIn(['reported', 'confirmed', 'assigned', 'in_progress', 'resolved', 'closed']).withMessage('Valid status required'),
  body('notes').optional().isString()
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { status, notes } = req.body;
    
    const leak = await Leak.findById(req.params.id);
    if (!leak) {
      return res.status(404).json({ message: 'Leak not found' });
    }

    // Update status with timeline
    await leak.updateStatus(status, req.user._id, req.userType, notes);

    // Emit real-time update
    const io = req.app.get('io');
    io.to('staff-room').emit('leak-status-updated', {
      leakId: leak._id,
      status: status,
      updatedBy: req.user.name,
      timestamp: new Date()
    });

    res.json({ 
      message: 'Leak status updated successfully',
      leak: leak 
    });

  } catch (error) {
    console.error('Update leak status error:', error);
    res.status(500).json({ message: 'Server error while updating leak status' });
  }
});

// @route   POST /api/leaks/:id/images
// @desc    Add images to leak report
// @access  Private
router.post('/:id/images', authenticateToken, [
  body('images').isArray().withMessage('Images array is required'),
  body('images.*.url').notEmpty().withMessage('Image URL is required'),
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { images } = req.body;
    
    const leak = await Leak.findById(req.params.id);
    if (!leak) {
      return res.status(404).json({ message: 'Leak not found' });
    }

    // Add images to leak
    leak.images.push(...images.map(img => ({
      ...img,
      uploadedAt: new Date()
    })));

    await leak.save();

    res.json({ 
      message: 'Images added successfully',
      leak: leak 
    });

  } catch (error) {
    console.error('Add images error:', error);
    res.status(500).json({ message: 'Server error while adding images' });
  }
});

// @route   POST /api/leaks/:id/service-request
// @desc    Create service request for a leak
// @access  Private (Staff only)
router.post('/:id/service-request', authenticateToken, [
  body('serviceType').isIn([
    'leak_repair', 'pipe_installation', 'drain_cleaning', 
    'fixture_repair', 'water_heater_service', 'emergency_service', 
    'inspection', 'maintenance'
  ]).withMessage('Valid service type required'),
  body('priority').isIn(['low', 'medium', 'high', 'emergency']).withMessage('Valid priority required')
], async (req, res) => {
  try {
    if (req.userType !== 'staff') {
      return res.status(403).json({ message: 'Only staff members can create service requests' });
    }

    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { serviceType, priority, scheduledDate, notes } = req.body;
    
    const leak = await Leak.findById(req.params.id);
    if (!leak) {
      return res.status(404).json({ message: 'Leak not found' });
    }

    if (leak.assignedService) {
      return res.status(400).json({ message: 'Service request already exists for this leak' });
    }

    // Create service request
    const serviceRequest = new ServiceRequest({
      leak: leak._id,
      requestedBy: req.user._id,
      serviceType,
      priority,
      location: leak.location,
      scheduledDate: scheduledDate || new Date(),
      status: 'pending'
    });

    if (notes) {
      serviceRequest.communication.push({
        from: req.user._id,
        fromType: 'User',
        message: notes
      });
    }

    await serviceRequest.save();
    
    // Link service request to leak
    leak.assignedService = serviceRequest._id;
    leak.status = 'assigned';
    await leak.save();

    // Emit to plumbers in area
    const io = req.app.get('io');
    io.to('plumber-room').emit('new-service-request', {
      serviceRequest: serviceRequest,
      leak: leak
    });

    res.status(201).json({
      message: 'Service request created successfully',
      serviceRequest: serviceRequest
    });

  } catch (error) {
    console.error('Create service request error:', error);
    res.status(500).json({ message: 'Server error while creating service request' });
  }
});

// @route   POST /api/leaks/iot-alert
// @desc    Handle IoT sensor alerts
// @access  Public (with API key authentication)
router.post('/iot-alert', async (req, res) => {
  try {
    const apiKey = req.header('X-API-Key');
    
    if (!apiKey || apiKey !== process.env.IOT_API_KEY) {
      return res.status(401).json({ message: 'Invalid API key' });
    }

    const {
      sensorId,
      location,
      sensorData,
      alertType,
      severity
    } = req.body;

    // Find a system user to report the leak
    const systemUser = await User.findOne({ role: 'admin' }) || await User.findOne();
    
    if (!systemUser) {
      return res.status(500).json({ message: 'No system user found to report leak' });
    }

    // Determine severity based on sensor data
    let determinedSeverity = severity || 'medium';
    if (sensorData.waterLevel > 80 || sensorData.flow > 100) {
      determinedSeverity = 'critical';
    } else if (sensorData.waterLevel > 60 || sensorData.flow > 50) {
      determinedSeverity = 'high';
    }

    // Create leak report
    const leak = new Leak({
      title: `IoT Sensor Alert - ${alertType}`,
      description: `Automated alert from sensor ${sensorId}. ${alertType} detected.`,
      severity: determinedSeverity,
      location,
      reportedBy: systemUser._id,
      reportMethod: 'iot_sensor',
      sensorData: {
        sensorId,
        ...sensorData,
        lastReading: new Date()
      },
      isEmergency: determinedSeverity === 'critical'
    });

    await leak.calculatePriority();
    await leak.save();

    // Emit real-time alert
    const io = req.app.get('io');
    io.to('staff-room').emit('iot-leak-alert', {
      leak: leak,
      sensorId: sensorId,
      alertType: alertType,
      timestamp: new Date()
    });

    // Auto-create emergency service request for critical alerts
    if (determinedSeverity === 'critical') {
      const serviceRequest = new ServiceRequest({
        leak: leak._id,
        requestedBy: systemUser._id,
        serviceType: 'emergency_service',
        priority: 'emergency',
        location: location,
        status: 'plumber_search'
      });

      await serviceRequest.save();
      
      leak.assignedService = serviceRequest._id;
      leak.status = 'assigned';
      await leak.save();

      io.to('plumber-room').emit('emergency-service-request', {
        serviceRequest: serviceRequest,
        leak: leak
      });
    }

    res.status(201).json({
      message: 'IoT alert processed successfully',
      leakId: leak._id,
      severity: determinedSeverity
    });

  } catch (error) {
    console.error('IoT alert error:', error);
    res.status(500).json({ message: 'Server error while processing IoT alert' });
  }
});

export default router;
